/*globals define */
/*jshint browser: true*/

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Wed May 18 2016 12:00:46 GMT-0500 (CDT).
 */

define([
    'widgets/TextEditor/TextEditorWidget',
    'underscore',
    'css!./styles/OperationCodeEditorWidget.css'
], function (
    TextEditorWidget,
    _
) {
    'use strict';

    var OperationCodeEditorWidget;
        //WIDGET_CLASS = 'operation-editor';

    OperationCodeEditorWidget = function (logger, container) {
        TextEditorWidget.call(this, logger, container);
    };

    _.extend(OperationCodeEditorWidget.prototype, TextEditorWidget.prototype);

    OperationCodeEditorWidget.prototype.getHeader = function (desc) {
        // Add comment about the inputs, attributes and references
        var inputs = desc.inputs.map(pair => `-- ${pair[0]} (${pair[1]})`).join('\n'),
            refs = desc.references.map(name => `-- ${name}`).join('\n'),
            outputs,
            header = [
                `-- Editing "${desc.name}"`,
                '-- '
            ];

        if (inputs.length) {
            header.push('-- Defined variables:');
            header.push(inputs);
        }
        if (refs) {
            header.push(refs);
        }
        header.push('--');

        // Add info about outputs
        outputs = desc.outputs.map(pair => `--   ${pair[0]} = <some ${pair[1]}>`)
            .join('\n');

        if (outputs.length) {
            header.push('-- Returning something like:');
            header.push('-- {');
            header.push(outputs);
            header.push('-- }');
        }

        return header.join('\n');
    };

    // Add the 'return' statement editing
    OperationCodeEditorWidget.prototype.updateNode = function (desc) {
        TextEditorWidget.prototype.updateNode.call(this, desc);
        var text = this.editor.getValue(),
            index = text.lastIndexOf('return'),
            currFooter,
            footer,
            outputs = desc.outputs.map(output => output[0]).sort(),
            content;

        if (this.editor.isFocused()) {
            return;
        }

        currFooter = text.substring(index);
        content = this.getFooterContent(currFooter);
        // Get the current types in the return statement
        footer = '\nreturn {';
        for (var i = 0; i < outputs.length; i++) {
            footer += `\n   ${outputs[i]} = ${content[outputs[i]] || 'nil'}`;
            if (i < outputs.length-1) {
                footer += ',';
            }
        }
        // Create the new return statement
        footer += '\n}';
        if (index > -1) {
            text = text.substring(0, index).replace(/\n$/, '') + footer;
        } else {
            text = text.replace(/\n$/, '') + footer;
        }
        this.editor.setValue(text, 2);
    };

    OperationCodeEditorWidget.prototype.getFooterContent = function (footer) {
        var table = footer.replace(/^return\s+{/, ''),
            unescapedQuote = /[^\\]['"]/g,
            content = {},
            pairs = table.split('='),
            matches,
            key,
            value;

        for (var i = 0; i < pairs.length; i+=2) {
            key = pairs[i];
            value = pairs[i+1];

            // Watch out for string literals. For now, we just don't provide this feature
            // on a bad parse FIXME
            matches = value.match(unescapedQuote);
            if (matches && matches.length%2 === 1) {  // bad parse
                return null;
            }
            content[key] = value.replace(/^\s*/, '').replace(/\s*$/, '');
        }
        return content;
    };

    return OperationCodeEditorWidget;
});
